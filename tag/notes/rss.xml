<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>流云阁 • Posts by &#34;notes&#34; tag</title>
        <link>https://evefortosaber.github.io</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
        <lastBuildDate>Sun, 19 Mar 2023 19:29:17 +0800</lastBuildDate>
        <category>Notes</category>
        <category>随笔</category>
        <category>C++</category>
        <category>CTF</category>
        <category>DFS</category>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2023/03/19/Mathematics/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6(%E4%B8%8B)/</guid>
            <title>高等数学(下)</title>
            <link>https://evefortosaber.github.io/2023/03/19/Mathematics/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6(%E4%B8%8B)/</link>
            <category>Notes</category>
            <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;关于高等数学下册的一些笔记&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;向量的方向角和方向余弦&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#向量的方向角和方向余弦&#34;&gt;#&lt;/a&gt; 向量的方向角和方向余弦&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;https://pic3.zhimg.com/80/v2-372cbaa699e447996d4c6d27ebbc4f2a_1440w.webp&#34; alt=&#34;向量的方向角和方向余弦&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;向量叉乘&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#向量叉乘&#34;&gt;#&lt;/a&gt; 向量叉乘&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在三维几何中，向量 a 和向量 b 的叉乘结果是一个向量，该向量垂直于 a 和 b 向量构成的平面，该向量也被称作法向量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://sunocean.life/blog/assets/images/201205-3d-linear-algebra/20160902232814429.jpg&#34; alt=&#34;矢量叉乘 - 小时百科&#34; /&gt;&lt;/p&gt;
&lt;p&gt;右手螺旋定则，手指指向左元。&lt;/p&gt;
&lt;h5 id=&#34;叉乘公式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#叉乘公式&#34;&gt;#&lt;/a&gt; 叉乘公式&lt;/h5&gt;
&lt;p&gt;&lt;em&gt;--- 行列式的展开&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-my.csdn.net/uploads/201704/19/1492585617_5108.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://pics3.baidu.com/feed/38dbb6fd5266d0166e8615243bd8d80d34fa3518.png@f_auto?token=ebf017fb7eacd318da1313abf2fc6484&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;平面方程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#平面方程&#34;&gt;#&lt;/a&gt; 平面方程&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;表达式&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;截距式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;x/a+y/b+z/c=1&lt;/strong&gt; 它与三坐标轴的交点分别为&lt;em&gt; P (a, 0, 0), Q (0, b, 0), R (0, 0, c)&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点法式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A(x-x0)+B(y-y0)+C(z-z0)=0&lt;/strong&gt; 法向量为&lt;strong&gt; n&lt;/strong&gt;=(A,B,C)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ax+By+Cz+D=0&lt;/strong&gt; 基本与点法式相同&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;可用平面上两条相交的直线的方向向量做点乘从而求出&lt;em&gt;平面法向量&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;空间直线&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#空间直线&#34;&gt;#&lt;/a&gt; 空间直线&lt;/h4&gt;
&lt;h5 id=&#34;空间直线方程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#空间直线方程&#34;&gt;#&lt;/a&gt; 空间直线方程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;两平面联立&lt;/li&gt;
&lt;li&gt;对称式，由方向向量和直线上一点确定&lt;/li&gt;
&lt;li&gt;参数式 // 可由对称式导出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;u&amp;gt; 详情戳&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc1MDk3Mi9hcnRpY2xlL2RldGFpbHMvMTIxMTcyNzkz&#34;&gt;链接&lt;/span&gt; &amp;lt;/u&amp;gt;&lt;/p&gt;
&lt;h4 id=&#34;空间曲面&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#空间曲面&#34;&gt;#&lt;/a&gt; 空间曲面&lt;/h4&gt;
&lt;h5 id=&#34;切面&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#切面&#34;&gt;#&lt;/a&gt; 切面&lt;/h5&gt;
&lt;p&gt;&lt;img data-src=&#34;https://picx.zhimg.com/v2-1a3899e4a5ec22962d64505ccd86dd29_720w.jpg?source=d16d100b&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2023/03/19/Mathematics/%E9%94%99%E9%A2%98%E6%9C%AC/</guid>
            <title>错题本</title>
            <link>https://evefortosaber.github.io/2023/03/19/Mathematics/%E9%94%99%E9%A2%98%E6%9C%AC/</link>
            <category>Notes</category>
            <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;数学错题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数学错题&#34;&gt;#&lt;/a&gt; 数学错题&lt;/h1&gt;
&lt;h2 id=&#34;高数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#高数&#34;&gt;#&lt;/a&gt; 高数&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/00_5-1663714277821.png&#34; alt=&#34;5&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/00_6-1663714314009.png&#34; alt=&#34;6&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/00_7-1663714323364.png&#34; alt=&#34;7&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/00_8-1663714341842.png&#34; alt=&#34;8&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/01_9-1663714386623.png&#34; alt=&#34;9&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/01_10-1663714362855.png&#34; alt=&#34;10&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2023/03/19/Mathematics/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
            <title>高等数学笔记一</title>
            <link>https://evefortosaber.github.io/2023/03/19/Mathematics/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
            <category>Notes</category>
            <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;高等数学一&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#高等数学一&#34;&gt;#&lt;/a&gt; 高等数学・一&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;学习时做的一些笔记，顺便对内容梳理一遍。^0&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;第一章-函数与极限&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一章-函数与极限&#34;&gt;#&lt;/a&gt; 第一章 函数与极限&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;第一节-映射与函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一节-映射与函数&#34;&gt;#&lt;/a&gt; 第一节 映射与函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;映射&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;与 x 所对应的 y 称为 x 在映射 f 下的象。&lt;br /&gt;
x 称为 y 在 f 下的原象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;满射、一一映射、单射、双射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A 映射得到的 B 集合等于映射的目标集合则是满射。&lt;/p&gt;
&lt;p&gt;对每个 y 都有唯一一个 x 对应，则是&lt;strong&gt;单射&lt;/strong&gt;或称&lt;strong&gt;一一映射&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;若 f 既是满射又是单射则称为&lt;strong&gt;双射&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数定义与表示方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特殊函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;狄利克雷函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/00_2.png&#34; alt=&#34;00_2&#34; title=&#34;狄利克雷函数&#34; /&gt;&lt;/p&gt;
&lt;p&gt;狄利克雷函数是一个定义在实数范围上、值域不连续的函数。狄利克雷函数的图像以 Y 轴为对称轴，是一个偶函数，它处处不连续，处处极限不存在，不可黎曼积分。这是一个处处不连续的可测函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;符号函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/00_3-1663132097343.png&#34; alt=&#34;00_3&#34; title=&#34;符号函数&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取整函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;raw.githubusercontent.com/EveFortosaber/Open-pictures/main/image-20220914131129520.png&#34; alt=&#34;image-20220914131129520&#34; /&gt;&lt;/p&gt;
&lt;p&gt;函数 y=[x] 称为取整函数，也称&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklQUIlOTglRTYlOTYlQUYlRTUlODclQkQlRTYlOTUlQjAvMjY3MDk1MT9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==&#34;&gt;高斯函数&lt;/span&gt;。其中不超过实数 x 的最大整数称为 x 的整数部分，记作 [x]。该函数被广泛应用于&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTglQUUlQkEvMzcwMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==&#34;&gt;数论&lt;/span&gt;，函数绘图和计算机领域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数的有界性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数 f (x) 在 D 上有界的充要条件是 f (x) 在 D 上既有上界又有下界。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数的单调性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单调增 (减) 函数&lt;/li&gt;
&lt;li&gt;严格单调增 (减) 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数的四则运算&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;复合函数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;形如： &lt;strong&gt;f(g(u(x)))&lt;/strong&gt; 或 &lt;strong&gt;f&lt;/strong&gt; o &lt;strong&gt;g&lt;/strong&gt; o &lt;strong&gt;u&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;反函数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反函数的单调性基本归纳于 &lt;strong&gt;先外后内，同增异减&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;初等函数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;初等函数是由&lt;strong&gt;幂函数（power function）、指数函数（exponential function）、对数函数（logarithmic function）、三角函数（trigonometric function）、反三角函数（inverse trigonometric function&lt;/strong&gt; 与常数经过有限次的有理运算（加、减、乘、除、有理数次乘方、有理数次开方）及有限次函数复合所产生，并且能用一个解析式表示的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;第二节-数列的极限&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第二节-数列的极限&#34;&gt;#&lt;/a&gt; 第二节 数列的极限&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;邻域&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻域&lt;/li&gt;
&lt;li&gt;去心邻域&lt;/li&gt;
&lt;li&gt;左 (右) 邻域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数列基本概念&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有限 or 无限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通项公式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整标函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子数列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单调性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作差或作商求单调性。有时候利用数列的单调性可能会得到惊喜的解题方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTUlODglOTclRTYlOUUlODElRTklOTklOTA/ZnJvbU1vZHVsZT1sZW1tYV9zZWFyY2gtYm94&#34;&gt;数列极限&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;收敛数列与数列的有界性&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;tip：数列收敛一定有界，数列有界不一定收敛&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;极限唯一性 &amp;amp; 有界性 &amp;amp; 保号性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;极限四则运算法则（严格意义上要分别证明数列的与函数的）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;第三节-函数的极限&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第三节-函数的极限&#34;&gt;#&lt;/a&gt; 第三节 函数的极限&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODclQkQlRTYlOTUlQjAlRTYlOUUlODElRTklOTklOTAvNzI3MDgz&#34;&gt;函数极限&lt;/span&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/00_1.png&#34; alt=&#34;00_1&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数某点极限存在的充要条件是左右极限都存在且相等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQjUlQjclRTYlQjYlODUlRTUlQUUlOUElRTclOTAlODY/ZnJvbU1vZHVsZT1sZW1tYV9zZWFyY2gtYm94&#34;&gt;海涅 (Heine) 定理&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求函数极限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的有限次函数，如果最高次项系数相等比较最高次项系数，如果不等，次数高的为高阶无穷大量。&lt;/li&gt;
&lt;li&gt;妙用，分子有理化，分母有理化。&lt;/li&gt;
&lt;li&gt;通分消去。&lt;/li&gt;
&lt;li&gt;立方差、因式分解。&lt;/li&gt;
&lt;li&gt;裂项等将无穷项收缩的方法。&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复合函数极限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;第四节-函数的连续性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第四节-函数的连续性&#34;&gt;#&lt;/a&gt; 第四节 函数的连续性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;连续性概念&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由极限的性质可知，一个函数在某点连续的充要条件是它在该点左右都连续。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间断点分类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2023/03/19/Mathematics/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
            <title>数学笔记二</title>
            <link>https://evefortosaber.github.io/2023/03/19/Mathematics/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
            <category>Notes</category>
            <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;数学笔记二&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数学笔记二&#34;&gt;#&lt;/a&gt; 数学笔记・二&lt;/h1&gt;
&lt;h3 id=&#34;第四节-函数的连续性承第一章函数与极限&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第四节-函数的连续性承第一章函数与极限&#34;&gt;#&lt;/a&gt; 第四节 函数的连续性（承第一章函数与极限）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;连续性概念&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由极限的性质可知，一个函数在某点连续的充要条件是它在该点左右都连续。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间断点分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第一类间断点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEYlQUYlRTUlOEUlQkIlRTklOTclQjQlRTYlOTYlQUQlRTclODIlQjk/ZnJvbU1vZHVsZT1sZW1tYV9pbmxpbms=&#34;&gt;可去间断点&lt;/span&gt;&lt;/strong&gt;：函数在该点左极限、右极限存在且相等，但不等于该点函数值或函数在该点无定义。如函数 y=（x^2-1)/(x-1) 在点 x=1 处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQjclQjMlRTglQjclODMlRTklOTclQjQlRTYlOTYlQUQlRTclODIlQjk/ZnJvbU1vZHVsZT1sZW1tYV9pbmxpbms=&#34;&gt;跳跃间断点&lt;/span&gt;&lt;/strong&gt;：函数在该点左极限、右极限存在，但不相等。如函数 y=|x|/x 在点 x=0 处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第二类间断点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E6%97%A0%E7%A9%B7%E9%97%B4%E6%96%AD%E7%82%B9/3531630?fromModule=lemma_inlink&#34;&gt;&lt;strong&gt;无穷间断点&lt;/strong&gt;&lt;/a&gt;：函数在该点可以无定义，且左极限、右极限至少有一个不存在，且函数在该点极限为∞。如函数 y=tanx 在点 x=π/2 处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOEMlQUYlRTglOEQlQTElRTklOTclQjQlRTYlOTYlQUQlRTclODIlQjk/ZnJvbU1vZHVsZT1sZW1tYV9pbmxpbms=&#34;&gt;振荡间断点&lt;/span&gt;&lt;/strong&gt;：函数在该点可以无定义，当自变量趋于该点时，函数值在两个常数间变动无限多次。如函数 y=sin (1/x) 在 x=0 处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由上述对各种间断点的描述可知，&lt;strong&gt;函数 f (x) 在第一类间断点的左右极限都存在，而函数 f (x) 在第二类间断点的左右极限至少有一个不存在&lt;/strong&gt;，这也是第一类间断点和第二类间断点的本质上的区别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第五节&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第五节&#34;&gt;#&lt;/a&gt; 第五节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;迫敛准则&lt;/p&gt;
&lt;p&gt;主要是放缩，抓住可合成量（如 N 个 1 求和为 n*(n+1)/2），和高阶量不变原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单调有界准则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单调有界数列必有极限。用于证明收敛很有用。&lt;/p&gt;
&lt;p&gt;求极限时可以&lt;strong&gt;先假设存在&lt;/strong&gt;。方便计算。&lt;s&gt;（避免求数列通项）&lt;/s&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;两个重要极限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/image-20220921223539147.png&#34; alt=&#34;image-20220921223539147&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第二个很重要，第一个可以直接看成等价无穷小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第六节&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第六节&#34;&gt;#&lt;/a&gt; 第六节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无穷小量&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;确切地说，当自变量 x 无限接近 x&amp;lt;sub&amp;gt;0&amp;lt;/sub&amp;gt;（或 x 的绝对值无限增大）时，函数值 f (x) 与 0 无限接近，即 f (x)→0 (或 f (x)=0)，则称 f (x) 为当 x→x&amp;lt;sub&amp;gt;0&amp;lt;/sub&amp;gt;(或 x→∞) 时的无穷小量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;等阶无穷小量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即两个无穷小量坐商得常数时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;等价无穷小量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即两个无穷小量坐商得 1。等价无穷小量可互换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常见等价无穷小量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://pica.zhimg.com/v2-f20a929bed77e97c61a9f83de9b4b5a4_r.jpg?source=1940ef5c&#34; alt=&#34;aa&#34; title=&#34;等价无穷小&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;关于我突然变水的原因&lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;实在是比较忙，各项内容也越来越复杂，所以就择取主要的知识点并舍去证明。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;以上。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;第二章&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第二章&#34;&gt;#&lt;/a&gt; 第二章&lt;/h2&gt;
&lt;h3 id=&#34;导数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#导数&#34;&gt;#&lt;/a&gt; 导数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;导数定义&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数可导一定连续，函数连续不一定可导。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求导法则&lt;/p&gt;
&lt;p&gt;注意除法，反函数，隐函数求导法则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;掌握反代的思想，掌握对数求导法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;含参求导&lt;/p&gt;
&lt;p&gt;一阶导可直接求二阶导可能需要反代。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意导数与微分的关系，如何二阶导隐函数。以及推导方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;断点处的导数求解，在有定义时使用求导法。&lt;/p&gt;
&lt;p&gt;在无定义时，使用定义法。(求极限)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高阶函数求导注意规律，和复合函数的导&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;微分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微分&#34;&gt;#&lt;/a&gt; 微分&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一元函数，可导则可微&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微分常数 A，与极限有关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微分运算类似求导法则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微分近似运算&lt;/p&gt;
&lt;p&gt;f(x)=f(x0)+f&#39;(x0)(x-x0)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了计算 f (x)，可找一个邻近于 x 的 x0，只要 f (x) 和 f&#39;(x) 容易计算，就可以利用这个公式计算 f (x) 的近似值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/%E5%BE%AE%E5%88%86%E8%BF%91%E4%BC%BC%E8%AE%A1%E7%AE%97.jpg&#34; alt=&#34;微分&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;第三章&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第三章&#34;&gt;#&lt;/a&gt; 第三章&lt;/h2&gt;
&lt;h3 id=&#34;微分中值定理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微分中值定理&#34;&gt;#&lt;/a&gt; 微分中值定理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;费马引理&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/%E8%B4%B9%E9%A9%AC%E5%BC%95%E7%90%86.jpg&#34; alt=&#34;费马引理&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;罗尔中值定理&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/%E7%BD%97%E5%B0%94%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86.jpg&#34; alt=&#34;罗尔中值定理&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉格朗日中值定理&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86.jpg&#34; alt=&#34;拉格朗日中值定理&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;柯西中值定理&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/%E6%9F%AF%E8%A5%BF%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86.jpg&#34; alt=&#34;柯西中值定理&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;洛必达法则&lt;/p&gt;
&lt;p&gt;泰勒公式&lt;/p&gt;
&lt;p&gt;麦克劳林公式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;佩亚诺余项&lt;/p&gt;
&lt;p&gt;高阶无穷小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉格朗日余项&lt;/p&gt;
&lt;p&gt;中值 -- 定量分析&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数的凹凸性&lt;/p&gt;
&lt;h2 id=&#34;第四章&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第四章&#34;&gt;#&lt;/a&gt; 第四章&lt;/h2&gt;
&lt;h4 id=&#34;不定积分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#不定积分&#34;&gt;#&lt;/a&gt; 不定积分&lt;/h4&gt;
&lt;h5 id=&#34;换元积分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#换元积分&#34;&gt;#&lt;/a&gt; 换元积分&lt;/h5&gt;
&lt;h5 id=&#34;分部积分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分部积分&#34;&gt;#&lt;/a&gt; 分部积分&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;凑微分，低次换元，三角换元，二次换元，重复型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;积分表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#积分表&#34;&gt;#&lt;/a&gt; 积分表&lt;/h5&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/%E7%A7%AF%E5%88%86%E8%A1%A8.jpg&#34; alt=&#34;积分表&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;有理函数的不定积分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#有理函数的不定积分&#34;&gt;#&lt;/a&gt; 有理函数的不定积分&lt;/h5&gt;
&lt;p&gt;待定系数法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;万能公式&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/%E4%B8%87%E8%83%BD%E5%85%AC%E5%BC%8F.jpg&#34; alt=&#34;万能公式&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;定积分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定积分&#34;&gt;#&lt;/a&gt; 定积分&lt;/h4&gt;
&lt;h5 id=&#34;定积分概念求无穷项和的极限&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定积分概念求无穷项和的极限&#34;&gt;#&lt;/a&gt; 定积分概念求无穷项和的极限&lt;/h5&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/%E5%AE%9A%E7%A7%AF%E5%88%86%E6%A6%82%E5%BF%B5.jpg&#34; alt=&#34;定积分概念&#34; /&gt;&lt;/p&gt;
&lt;h5 id=&#34;估值定理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#估值定理&#34;&gt;#&lt;/a&gt; 估值定理&lt;/h5&gt;
&lt;p&gt;区间内的 Max 与 Min 乘以区间长度得到限定区间。&lt;/p&gt;
&lt;h5 id=&#34;积分中值定理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#积分中值定理&#34;&gt;#&lt;/a&gt; 积分中值定理&lt;/h5&gt;
&lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/%E7%A7%AF%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86.jpg&#34; alt=&#34;积分中值定理&#34; /&gt;&lt;/p&gt;
&lt;p&gt;求积分函数极限时用到，由介值定理推得&lt;/p&gt;
&lt;h5 id=&#34;几何意义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#几何意义&#34;&gt;#&lt;/a&gt; 几何意义&lt;/h5&gt;
&lt;h5 id=&#34;牛顿莱布尼茨公式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#牛顿莱布尼茨公式&#34;&gt;#&lt;/a&gt; 牛顿莱布尼茨公式&lt;/h5&gt;
&lt;h5 id=&#34;微积分学基本定理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微积分学基本定理&#34;&gt;#&lt;/a&gt; 微积分学基本定理&lt;/h5&gt;
&lt;p&gt;连续函数必存在原函数&lt;/p&gt;
&lt;h5 id=&#34;平面曲线的弧长与曲率&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#平面曲线的弧长与曲率&#34;&gt;#&lt;/a&gt; 平面曲线的弧长与曲率&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/1%E5%BC%A7%E9%95%BF%E5%85%AC%E5%BC%8F.png&#34; alt=&#34;1弧长公式&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/2%E5%BC%A7%E9%95%BF%E5%85%AC%E5%BC%8F.png&#34; alt=&#34;2&#34; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/3%E5%BC%A7%E9%95%BF%E5%85%AC%E5%BC%8F.png&#34; alt=&#34;3&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;极坐标系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#极坐标系&#34;&gt;#&lt;/a&gt; 极坐标系&lt;/h5&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;x=pcosa,y=psina;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&#34;平面曲线的曲率&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#平面曲线的曲率&#34;&gt;#&lt;/a&gt; 平面曲线的曲率&lt;/h5&gt;
&lt;h5 id=&#34;曲率圆&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#曲率圆&#34;&gt;#&lt;/a&gt; 曲率圆&lt;/h5&gt;
&lt;h5 id=&#34;定积分的几何应用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定积分的几何应用&#34;&gt;#&lt;/a&gt; 定积分的几何应用&lt;/h5&gt;
&lt;h5 id=&#34;连续函数的平均值&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#连续函数的平均值&#34;&gt;#&lt;/a&gt; 连续函数的平均值&lt;/h5&gt;
&lt;h5 id=&#34;定积分在物理学与经济学&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定积分在物理学与经济学&#34;&gt;#&lt;/a&gt; 定积分在物理学与经济学&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变力做功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引力问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;液体侧面压力&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;反常积分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#反常积分&#34;&gt;#&lt;/a&gt; 反常积分&lt;/h5&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E5%A4%9A%E5%A4%9A%E6%9E%9C%E5%AD%90%E9%97%AE%E9%A2%98/</guid>
            <title>多多果子问题二叉堆与优先序列</title>
            <link>https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E5%A4%9A%E5%A4%9A%E6%9E%9C%E5%AD%90%E9%97%AE%E9%A2%98/</link>
            <category>Notes</category>
            <category>C++</category>
            <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;img data-src=&#34;https://s2.loli.net/2023/03/16/No51BErYemDLZpQ.jpg&#34; alt=&#34;37&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;问题描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#问题描述&#34;&gt;#&lt;/a&gt; 问题描述：&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。&lt;/p&gt;
&lt;p&gt;因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。&lt;br /&gt;
　　例如有 3 种果子，数目依次为 1，2，9。可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。&lt;br /&gt;
所以多多总共耗费体力 = 3+12=15。可以证明 15 为最小的体力耗费值。&lt;br /&gt;
输入&lt;br /&gt;
　　输入包括两行，第一行是一个整数 n (1&amp;lt;＝n&amp;lt;=10000)，表示果子的种类数。&lt;br /&gt;
　　第二行包含 n 个整数，用空格分隔，第 i 个整数 ai (1&amp;lt;＝ai&amp;lt;=20000) 是第 i 种果子的数目。&lt;br /&gt;
输出&lt;br /&gt;
　　输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^31。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解决问题思路&lt;/strong&gt;：取出最小相加成一堆，并计算体力消耗&lt;/p&gt;
&lt;h4 id=&#34;方法一小顶堆&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#方法一小顶堆&#34;&gt;#&lt;/a&gt; 方法一：小顶堆&lt;/h4&gt;
&lt;p&gt;代码及思路如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;

using namespace std;
const int maxn=10086;
void updateheap(int heap[],int idx,int high)// 在本身是小顶堆的情况下维护
&amp;#123;
    int i=idx,j=2*i;//
    while(j&amp;lt;=high)
    &amp;#123;
        if(j+1&amp;lt;=high &amp;amp;&amp;amp; heap[j]&amp;gt;heap[j+1]) j=j+1;
        if(heap[j]&amp;lt;heap[i]) swap(heap[j],heap[i]);// 当需要进行维护操作时，就说明idx节点不满足小顶堆，要考虑swap后对子节点的影响
        else break;//  在它本身是小顶堆的情况下，确保了维护的这个节点满足条件即可结束
        i=j; // 考虑到子节点的影响，继续对子节点判断维护
        j=2*i;
    &amp;#125;
&amp;#125;

void heapinit(int heap[],int len) // 创建一个小顶堆，len是小顶堆大小
&amp;#123;
    for(int i=1;i&amp;lt;=len;i++) cin&amp;gt;&amp;gt;heap[i]; // 空间足够，以1为根结点 事实上，一般都以1为节点
    for(int i=len/2;i&amp;gt;0;i--) updateheap(heap,i,len); // 从叶子向根节点维护，确保有序性
&amp;#125;

void deletetop(int heap[],int &amp;amp;n) // n即size将要移除的数放到末尾，并回收末尾节点 = size-- 
&amp;#123;
    
    swap(heap[1],heap[n]);// change happans ,we have to maintain it
    n--; // after swap we recycle the last node
    updateheap(heap,1,n);
    
&amp;#125;
void insertheap(int heap[],int &amp;amp;n,int value)
&amp;#123;
    n++;
    heap[n]=value;
    int i=n,j=i/2;// i is the childnode, and j is the fathernode
    while(i&amp;gt;1)
    &amp;#123;
        if(heap[i]&amp;lt;heap[j]) swap(heap[i],heap[j]);
        else return; // heap[i]&amp;gt;=heap[j]说明插入的值并不比父节点大，有序性得以保证
        i=j;
        j=i/2;
    &amp;#125;
    return;
&amp;#125;
int main()
&amp;#123;
    int n,Heap[maxn],stamina,size;
    cin&amp;gt;&amp;gt;n;
    size=n;
    stamina=0;
    heapinit(Heap,n);
    if(n==1)
    &amp;#123;
        cout&amp;lt;&amp;lt;Heap[1];
        return 1;
    &amp;#125;
    // stamina 的消耗可以堆顶的访问删除来实现
    // 通过将堆顶与堆底互换并回收堆底，保持访问堆的结构不变，通过维护保持堆的有序
    // 回收（size--通过大小的减小停止对堆底的维护，即回收）未删除数据但不影响
    while(size&amp;gt;1)
    &amp;#123;
        int a = Heap[1];
        deletetop(Heap,size);
        int b=Heap[1];
        deletetop(Heap,size);
       
        insertheap(Heap,size,a+b);// value isn&#39;t equal to stamina cost totally
        stamina+=(a+b);

    &amp;#125;
    cout&amp;lt;&amp;lt;stamina;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结语：涉及二叉堆的生成与维护，要注意对堆顶 pop 时 (也就是上文中的 deletetop 函数，topnode 的值并没有被删除，而是放在了堆底回收区，堆的大小并不是真正意义上所占全部空间的大小，而是有效空间的大小)&lt;/p&gt;
&lt;h4 id=&#34;方法二优先队列&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#方法二优先队列&#34;&gt;#&lt;/a&gt; 方法二：优先队列&lt;/h4&gt;
&lt;p&gt;代码及思路如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;queue&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

int main()
&amp;#123;
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; que;
    // greater 增序，使最小的位于top
    int n, i, stamina = 0;
    cin &amp;gt;&amp;gt; n;
    i = n;
    while (i--)
    &amp;#123;
        int x;
        cin &amp;gt;&amp;gt; x;
        que.push(x);
    &amp;#125;// 输入que，自动排序
    if (n == 1)
    &amp;#123;
        int x = que.top();
        cout &amp;lt;&amp;lt; x;
        que.pop();
    &amp;#125;
    while (que.size() &amp;gt; 1)
    &amp;#123;
        int a = que.top();
        que.pop();
        int b = que.top();
        que.pop();
        stamina += (a + b);
        que.push(a + b);
    &amp;#125;
    //que.top()=sum 所有之和，不用计算到体力消耗


    cout &amp;lt;&amp;lt; stamina;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结语：相比于使用小顶堆，使用优先队列的代码无疑简介易懂。&lt;/p&gt;
&lt;p&gt;然而事实上优先队列本质上使用的也是堆的思想。二者在时间效率上，是前者更优。&lt;s&gt;(specific 优于 general)&lt;/s&gt; 😃&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3QuY3Nkbi5jbi82dXBFSw==&#34;&gt;Possible_Answer&lt;/span&gt;,&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xODc2MTg0NTA=&#34;&gt; 二叉堆 -- 知乎&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3QuY3Nkbi5jbi8yQ1o0YQ==&#34;&gt;优先队列&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3QuY3Nkbi5jbi9DNlA0aA==&#34;&gt;优先队列 (实例)&lt;/span&gt;,&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTU0NjcwMDA=&#34;&gt;数据结构 —— 哈夫曼树 (Huffman Tree)&lt;/span&gt;,(知识扩展)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;写在最后，这里出于课程要求，并没有考虑快排的方法，事实上快排无疑也是一种解决方案&lt;/p&gt;
&lt;/blockquote&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E5%B0%8F%E6%9C%A8%E6%A3%8D%E7%BB%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</guid>
            <title>小木棍组正方形</title>
            <link>https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E5%B0%8F%E6%9C%A8%E6%A3%8D%E7%BB%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</link>
            <category>Notes</category>
            <category>C++</category>
            <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;小木棍组正方形：&lt;/p&gt;
&lt;p&gt;解题思路：&lt;/p&gt;
&lt;p&gt;使用 DFS 算法，并减去一些枝干&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;
int sticks[38]&amp;#123;0&amp;#125;;//存放木棍长度

int side, groupnum, n;
bool DFS(int sum, int number, int pos,int * flag)
&amp;#123;
    if (number == 3)
        return true;

    for(int i=pos;i&amp;lt;n;i++)
    &amp;#123;
        if(sum+sticks[pos]&amp;gt;side)&amp;#123;
            continue;
        &amp;#125;
        if(flag[i]==1)
        &amp;#123;
            continue;
        &amp;#125;
        if(sum+sticks[i]==side)// 深度搜索
        &amp;#123;
            if(DFS(0,number+1,0,flag)) return true;
        &amp;#125;
        else
        &amp;#123;
            if(DFS(sum+sticks[i],number,0,flag)) return true;
        &amp;#125;//深度搜索不能返回true，则返回上一节点，寻找其他子节点，通过for实现
        flag[i]=0;
    &amp;#125;
    return false;
&amp;#125;

int main()
&amp;#123;

    cin &amp;gt;&amp;gt; groupnum;
    while (groupnum--)
    &amp;#123;
        int flag[38]&amp;#123;0&amp;#125;;
        cin &amp;gt;&amp;gt; n;
        int s = 0;
        for (int i = 0; i &amp;lt; n; i++)
        &amp;#123;
            cin &amp;gt;&amp;gt; sticks[i];
            s += sticks[i];
        &amp;#125;
        if (s % 4 != 0)
        &amp;#123;
            cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot; &amp;lt;&amp;lt; endl;
            continue;
        &amp;#125;
        side = s / 4;

        sort(sticks, sticks + n, greater&amp;lt;int&amp;gt;());
        if (sticks[0] &amp;gt; side)
        &amp;#123;
            cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot; &amp;lt;&amp;lt; endl;
            continue;
        &amp;#125;
        if (DFS(0, 0, 0,flag))
            cout &amp;lt;&amp;lt; &amp;quot;yes&amp;quot; &amp;lt;&amp;lt; endl;
        else 
            cout&amp;lt;&amp;lt;&amp;quot;no&amp;quot;&amp;lt;&amp;lt;endl;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结语：&lt;/p&gt;
&lt;p&gt;DFS 模板&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int check(参数)
&amp;#123;
    if(满足条件)
        return 1;
    return 0;
&amp;#125;
 
void dfs(int step)
&amp;#123;
        判断边界
        &amp;#123;
            相应操作
        &amp;#125;
        尝试每一种可能
        &amp;#123;
               满足check条件
               标记
               继续下一步dfs(step+1)
               恢复初始状态（回溯的时候要用到）
        &amp;#125;
&amp;#125;   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3QuY3Nkbi5jbi9FZjhNUQ==&#34;&gt;http://t.csdn.cn/Ef8MQ&lt;/span&gt; DFS 算法解释及例题&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E7%B4%A0%E6%95%B0%E7%8E%AF%E9%97%AE%E9%A2%98/</guid>
            <title>素数环问题</title>
            <link>https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E7%B4%A0%E6%95%B0%E7%8E%AF%E9%97%AE%E9%A2%98/</link>
            <category>Notes</category>
            <category>C++</category>
            <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;img data-src=&#34;https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/picgo/1267999.jpg&#34; alt=&#34;1267999&#34; /&gt;&lt;/p&gt;
&lt;p&gt;素数环问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Problem Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A ring is compose of n circles as shown in diagram. Put natural number 1, 2, ..., n into each circle separately, and the sum of numbers in two adjacent circles should be a prime.&lt;/p&gt;
&lt;p&gt;Note: the number of first circle should always be 1.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Input&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;n (0 &amp;lt; n &amp;lt; 20).&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and anticlockwisely. The order of numbers must satisfy the above requirements. Print solutions in lexicographical order.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;You are to write a program that completes above process.&lt;/p&gt;
&lt;p&gt;&amp;lt;u&amp;gt;&lt;strong&gt;Print a blank line after each case.&lt;/strong&gt;&amp;lt;/u&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解题思路：&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
#include&amp;lt;math.h&amp;gt; 
#include&amp;lt;string.h&amp;gt;
using namespace std;
/*
从2开始到sqrt(num)，逐一判断
*/
int n;
int arry[27]&amp;#123;1&amp;#125;,flag[27]&amp;#123;0&amp;#125;;
stack&amp;lt;int&amp;gt; s1, s2;

bool isPrime_2(int num)
&amp;#123;
    if (num == 1 || num == 4)
        return 0;
    if (num == 2 || num == 3)
        return 1;
    int temp = sqrt(num);
    for (int i = 2; i &amp;lt;= temp; i++)
    &amp;#123;
        if (num % i == 0)
            return 0;
    &amp;#125;
    return 1;
&amp;#125;


void dfs(int k)
&amp;#123;
    if(k==n&amp;amp;&amp;amp;isPrime_2(arry[0]+arry[n-1])) //如果递归到下标n并且满足条件就找到一组正确的数据了
    &amp;#123;
        for(int i=0;i&amp;lt;n-1;i++)
        cout&amp;lt;&amp;lt;arry[i]&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        cout&amp;lt;&amp;lt;arry[n-1]&amp;lt;&amp;lt;endl;
    &amp;#125;
    else
    &amp;#123;
        for(int i=2;i&amp;lt;=n;i++)
        if(flag[i]==0&amp;amp;&amp;amp;isPrime_2(arry[k-1]+i)) //如果i没有使用过，并且a[k-1]和i相加为素数
        &amp;#123;
            arry[k]=i;     //记录下标的值
            flag[i]=1; //标记为使用过的
            dfs(k+1);  //开始下一个下标的计算
            flag[i]=0;//清除标记
        &amp;#125;
    &amp;#125;
&amp;#125;

int main()
&amp;#123;
    int i=0;
    while (cin &amp;gt;&amp;gt; n)
    &amp;#123;
        i++;
        memset(flag,0,sizeof(flag));
        for (int k = 0; k &amp;lt; n; k++)
            arry[k] = 1;
        cout&amp;lt;&amp;lt;&amp;quot;Case &amp;quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&#39;:&#39;&amp;lt;&amp;lt;endl;
        flag[0]=1;
        dfs(1);
        cout&amp;lt;&amp;lt;endl;
        

    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结语：&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[源码借鉴 From 简书]( &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85MThiZWM3MzJiN2Q=&#34;&gt;DFS (素数环) - 简书 (jianshu.com)&lt;/span&gt;)，&lt;/p&gt;
&lt;/blockquote&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</guid>
            <title>棋盘问题</title>
            <link>https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</link>
            <category>Notes</category>
            <category>C++</category>
            <category>DFS</category>
            <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
            <description><![CDATA[ &lt;h4 id=&#34;问题描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#问题描述&#34;&gt;#&lt;/a&gt; 问题描述&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放 k 个棋子的所有可行的摆放方案 C。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;输入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输入&#34;&gt;#&lt;/a&gt; 输入&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;输入含有多组测试数据。&lt;br /&gt;
每组数据的第一行是两个正整数 *，n k*，用一个空格隔开，表示了将在一个 n*n 的矩阵内描述棋盘，以及摆放棋子的数目。&lt;/p&gt;
&lt;p&gt;n &amp;lt;= 8 , k &amp;lt;= n&lt;/p&gt;
&lt;p&gt;当为 **-1 -1** 时表示输入结束。&lt;br /&gt;
随后的 n 行描述了棋盘的形状：每行有 n 个字符，其中  &lt;code&gt;#&lt;/code&gt;  表示棋盘区域， &lt;code&gt;.&lt;/code&gt;  表示空白区域（数据保证不出现多余的空白行或者空白列）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输出&#34;&gt;#&lt;/a&gt; 输出&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;对于每一组数据，给出一行输出，输出摆放的方案数目 C （&lt;em&gt;数据保证 C&amp;lt;2^31&lt;/em&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;样例输入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#样例输入&#34;&gt;#&lt;/a&gt; 样例输入&lt;/h5&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;figcaption data-lang=&#34;plain&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;2 1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.#&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;4 4&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;...#&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;..#.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.#..&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;-1 -1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h5 id=&#34;样例输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#样例输出&#34;&gt;#&lt;/a&gt; 样例输出&lt;/h5&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;figcaption data-lang=&#34;plain&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 id=&#34;解题思路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#解题思路&#34;&gt;#&lt;/a&gt; 解题思路&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;代码如下&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;
using namespace std;

int n, k, ans, a[64], j; // n 方阵长度，k棋子个数,ans is answer

int visit[8][8]&amp;#123;0&amp;#125;; // shows which cloumn and row is not placeable

struct Node
&amp;#123;
    int *flag;
    int p = 0;// in fact, the param is redundant
&amp;#125;;
// 如果为0则空，1则有棋盘’#‘
Node qiju[100];
// 进行遍历// 考虑使用下标 从1开始

void dfs(int idx, int num)
&amp;#123;
    if (num == k)
        ans++; // plan + 1
    else
    &amp;#123;
        for (int i = idx; i &amp;lt; j; i++) // each qipan has possiblity
        &amp;#123;
            if (*qiju[a[i]].flag == 1)
                continue;
            *qiju[a[i]].flag = 1; //
            dfs(0, num + 1);
        &amp;#125;
    &amp;#125;
&amp;#125;

int main()
&amp;#123;
    char ch;
    while (cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k)
    &amp;#123;
        if (n == -1 &amp;amp;&amp;amp; k == -1)
            break;
        j = 0;
        ans = 0;
        memset(qiju, 0, sizeof(qiju));
        memset(visit, 0, sizeof(visit));

        for (int i = 0; i &amp;lt; n * n; i++)
        &amp;#123;

            cin &amp;gt;&amp;gt; ch;
            switch (ch)
            &amp;#123;
            case &#39;.&#39;:
                break;
            case &#39;#&#39;:

                qiju[i].p = 1;// when I have created array a, 
                    		//I can visit qiju by a, 
                    		//in this situation param p is redundant.
                qiju[i].flag = &amp;amp;visit[i / n][i % n]; // point to position
                a[j] = i;                            // restore qipan position with arry a
                j++;
                break;
            &amp;#125;
        &amp;#125;
        dfs(0, 0);
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;结语&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结语&#34;&gt;#&lt;/a&gt; 结语&lt;/h4&gt;
&lt;p&gt;通过 visit 标记状态，通过 node 取地址，使每个棋盘的状态得以被标示，同时通过 node 数组，a 数组实现快速访问，规避无效数据。&lt;/p&gt;
&lt;h4 id=&#34;参考资料&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#参考资料&#34;&gt;#&lt;/a&gt; 参考资料&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;DFS 深度优先搜索算法&lt;/p&gt;
&lt;/blockquote&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</guid>
            <title>迷宫问题</title>
            <link>https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</link>
            <category>Notes</category>
            <category>C++</category>
            <category>DFS</category>
            <pubDate>Sun, 19 Mar 2023 19:29:17 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;解决思路&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;p&gt;结语：&lt;/p&gt;
&lt;p&gt;迷宫问题很重要的就是路径，方向，路径使用栈，方向通过 2X4 的数组描述，关键在于，在平面上点的坐标可以用 (x,y) 描述，给它加上&lt;/p&gt;
&lt;p&gt;(1,0)((-1,0),(0,1),(0,-1)) 就实现了向右 (左，上，下) 移动。&lt;/p&gt;
&lt;p&gt;参考资料&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://evefortosaber.github.io/2022/09/07/zhaji/Note%20of%20markdown/</guid>
            <title>Notes Of Markdown</title>
            <link>https://evefortosaber.github.io/2022/09/07/zhaji/Note%20of%20markdown/</link>
            <category>Notes</category>
            <pubDate>Wed, 07 Sep 2022 23:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;为了搭建自己的 blog，clone 了个模板。现在也是时候该来学写 blog 了。 &lt;s&gt;（什么写 blog 还要学不是有手就行？？）&lt;/s&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&#34;note-of-markdown&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#note-of-markdown&#34;&gt;#&lt;/a&gt; Note Of Markdown&lt;/h1&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;1-准备preparation&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-准备preparation&#34;&gt;#&lt;/a&gt; 1. 准备（Preparation）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用软件：Video Studio Code&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作文件：makedown (后缀为 &lt;code&gt;.md&lt;/code&gt; ）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;2-开始beginning&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-开始beginning&#34;&gt;#&lt;/a&gt; 2. 开始（Beginning）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建一个文本文档更改后缀为 &lt;code&gt;.md&lt;/code&gt;  然后用 Visual Studio Code 打开，或者先打开 Visual Studio Code 然后新建一个后缀为 &lt;code&gt;.md&lt;/code&gt;  的文件。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打开侧边预览&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;在view中打开 Command Palette 然后输入Open Preview to the Side
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;3语法grammar&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3语法grammar&#34;&gt;#&lt;/a&gt; 3. 语法（Grammar）&lt;/h3&gt;
&lt;h5 id=&#34;标题title&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#标题title&#34;&gt;#&lt;/a&gt; 标题（Title)&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;标题可分为一到六级分别用 #、##、###...... 以此类推&lt;br /&gt;
其中 #表示的最大，###### 最小。语法如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# 标题1
## 标题2
### 标题3
...
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;换行直接回车&lt;/li&gt;
&lt;li&gt;字体
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*内容*&lt;/code&gt;  为斜体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**内容**&lt;/code&gt;  为加粗&lt;/li&gt;
&lt;li&gt;&lt;code&gt;***内容***&lt;/code&gt;  为粗斜体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~~内容~~&lt;/code&gt;  为删除线&lt;br /&gt;
表现：&lt;em&gt;内容&lt;/em&gt;、&lt;strong&gt;内容&lt;/strong&gt;、&lt;em&gt;&lt;strong&gt;内容&lt;/strong&gt;&lt;/em&gt;、&lt;s&gt;内容&lt;/s&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4插入insert&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4插入insert&#34;&gt;#&lt;/a&gt; 4. 插入 (Insert)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入图片&lt;/p&gt;
&lt;figure class=&#34;highlight markdown&#34;&gt;&lt;figcaption data-lang=&#34;markdown&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;![图片名称](图片链接 &#39;Alt&#39;)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入链接&lt;/p&gt;
&lt;figure class=&#34;highlight markdown&#34;&gt;&lt;figcaption data-lang=&#34;markdown&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token url&#34;&gt;[&lt;span class=&#34;token content&#34;&gt;内容&lt;/span&gt;](&lt;span class=&#34;token url&#34;&gt;链接&lt;/span&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;混合使用&lt;/p&gt;
&lt;figure class=&#34;highlight markdown&#34;&gt;&lt;figcaption data-lang=&#34;markdown&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;[![图片名称](图片链接 &#39;Alt&#39;)](链接)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这样就对图片添加了超链接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5其他&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5其他&#34;&gt;#&lt;/a&gt; 5. 其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工具&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly90eXBvcmFpby5jbi8=&#34;&gt;Typro&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更多语法参照&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucnVub29iLmNvbS9odG1sL2h0bWwtdHV0b3JpYWwuaHRtbA==&#34;&gt; HTML&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
