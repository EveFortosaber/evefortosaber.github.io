{
    "version": "https://jsonfeed.org/version/1",
    "title": "流云阁 • All posts by \"c++\" tag",
    "description": "",
    "home_page_url": "https://evefortosaber.github.io",
    "items": [
        {
            "id": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E7%B4%A0%E6%95%B0%E7%8E%AF%E9%97%AE%E9%A2%98/",
            "url": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E7%B4%A0%E6%95%B0%E7%8E%AF%E9%97%AE%E9%A2%98/",
            "title": "素数环问题",
            "date_published": "2023-03-19T11:29:17.362Z",
            "content_html": "<p><img data-src=\"https://raw.githubusercontent.com/EveFortosaber/Open-pictures/main/picgo/1267999.jpg\" alt=\"1267999\" /></p>\n<p>素数环问题</p>\n<blockquote>\n<p><strong>Problem Description</strong></p>\n<p>A ring is compose of n circles as shown in diagram. Put natural number 1, 2, ..., n into each circle separately, and the sum of numbers in two adjacent circles should be a prime.</p>\n<p>Note: the number of first circle should always be 1.</p>\n<hr />\n<p><strong>Input</strong></p>\n<p>n (0 &lt; n &lt; 20).</p>\n<hr />\n<p><strong>Output</strong></p>\n<p>The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and anticlockwisely. The order of numbers must satisfy the above requirements. Print solutions in lexicographical order.</p>\n<hr />\n<p>You are to write a program that completes above process.</p>\n<p>&lt;u&gt;<strong>Print a blank line after each case.</strong>&lt;/u&gt;</p>\n</blockquote>\n<p>解题思路：</p>\n<p>代码如下：</p>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include&lt;math.h&gt; \n#include&lt;string.h&gt;\nusing namespace std;\n/*\n从2开始到sqrt(num)，逐一判断\n*/\nint n;\nint arry[27]&#123;1&#125;,flag[27]&#123;0&#125;;\nstack&lt;int&gt; s1, s2;\n\nbool isPrime_2(int num)\n&#123;\n    if (num == 1 || num == 4)\n        return 0;\n    if (num == 2 || num == 3)\n        return 1;\n    int temp = sqrt(num);\n    for (int i = 2; i &lt;= temp; i++)\n    &#123;\n        if (num % i == 0)\n            return 0;\n    &#125;\n    return 1;\n&#125;\n\n\nvoid dfs(int k)\n&#123;\n    if(k==n&amp;&amp;isPrime_2(arry[0]+arry[n-1])) //如果递归到下标n并且满足条件就找到一组正确的数据了\n    &#123;\n        for(int i=0;i&lt;n-1;i++)\n        cout&lt;&lt;arry[i]&lt;&lt;&quot; &quot;;\n        cout&lt;&lt;arry[n-1]&lt;&lt;endl;\n    &#125;\n    else\n    &#123;\n        for(int i=2;i&lt;=n;i++)\n        if(flag[i]==0&amp;&amp;isPrime_2(arry[k-1]+i)) //如果i没有使用过，并且a[k-1]和i相加为素数\n        &#123;\n            arry[k]=i;     //记录下标的值\n            flag[i]=1; //标记为使用过的\n            dfs(k+1);  //开始下一个下标的计算\n            flag[i]=0;//清除标记\n        &#125;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    int i=0;\n    while (cin &gt;&gt; n)\n    &#123;\n        i++;\n        memset(flag,0,sizeof(flag));\n        for (int k = 0; k &lt; n; k++)\n            arry[k] = 1;\n        cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;':'&lt;&lt;endl;\n        flag[0]=1;\n        dfs(1);\n        cout&lt;&lt;endl;\n        \n\n    &#125;\n&#125;\n</code></pre>\n<p>结语：</p>\n<p>参考资料：</p>\n<blockquote>\n<p>[源码借鉴 From 简书]( <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85MThiZWM3MzJiN2Q=\">DFS (素数环) - 简书 (jianshu.com)</span>)，</p>\n</blockquote>\n",
            "tags": [
                "Notes",
                "C++"
            ]
        },
        {
            "id": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E5%A4%9A%E5%A4%9A%E6%9E%9C%E5%AD%90%E9%97%AE%E9%A2%98/",
            "url": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E5%A4%9A%E5%A4%9A%E6%9E%9C%E5%AD%90%E9%97%AE%E9%A2%98/",
            "title": "多多果子问题二叉堆与优先序列",
            "date_published": "2023-03-19T11:29:17.362Z",
            "content_html": "<p><img data-src=\"https://s2.loli.net/2023/03/16/No51BErYemDLZpQ.jpg\" alt=\"37\" /></p>\n<h4 id=\"问题描述\"><a class=\"anchor\" href=\"#问题描述\">#</a> 问题描述：</h4>\n<blockquote>\n<p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p>\n<p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。<br />\n　　例如有 3 种果子，数目依次为 1，2，9。可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。<br />\n所以多多总共耗费体力 = 3+12=15。可以证明 15 为最小的体力耗费值。<br />\n输入<br />\n　　输入包括两行，第一行是一个整数 n (1&lt;＝n&lt;=10000)，表示果子的种类数。<br />\n　　第二行包含 n 个整数，用空格分隔，第 i 个整数 ai (1&lt;＝ai&lt;=20000) 是第 i 种果子的数目。<br />\n输出<br />\n　　输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^31。</p>\n</blockquote>\n<p><strong>解决问题思路</strong>：取出最小相加成一堆，并计算体力消耗</p>\n<h4 id=\"方法一小顶堆\"><a class=\"anchor\" href=\"#方法一小顶堆\">#</a> 方法一：小顶堆</h4>\n<p>代码及思路如下</p>\n<pre><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\nconst int maxn=10086;\nvoid updateheap(int heap[],int idx,int high)// 在本身是小顶堆的情况下维护\n&#123;\n    int i=idx,j=2*i;//\n    while(j&lt;=high)\n    &#123;\n        if(j+1&lt;=high &amp;&amp; heap[j]&gt;heap[j+1]) j=j+1;\n        if(heap[j]&lt;heap[i]) swap(heap[j],heap[i]);// 当需要进行维护操作时，就说明idx节点不满足小顶堆，要考虑swap后对子节点的影响\n        else break;//  在它本身是小顶堆的情况下，确保了维护的这个节点满足条件即可结束\n        i=j; // 考虑到子节点的影响，继续对子节点判断维护\n        j=2*i;\n    &#125;\n&#125;\n\nvoid heapinit(int heap[],int len) // 创建一个小顶堆，len是小顶堆大小\n&#123;\n    for(int i=1;i&lt;=len;i++) cin&gt;&gt;heap[i]; // 空间足够，以1为根结点 事实上，一般都以1为节点\n    for(int i=len/2;i&gt;0;i--) updateheap(heap,i,len); // 从叶子向根节点维护，确保有序性\n&#125;\n\nvoid deletetop(int heap[],int &amp;n) // n即size将要移除的数放到末尾，并回收末尾节点 = size-- \n&#123;\n    \n    swap(heap[1],heap[n]);// change happans ,we have to maintain it\n    n--; // after swap we recycle the last node\n    updateheap(heap,1,n);\n    \n&#125;\nvoid insertheap(int heap[],int &amp;n,int value)\n&#123;\n    n++;\n    heap[n]=value;\n    int i=n,j=i/2;// i is the childnode, and j is the fathernode\n    while(i&gt;1)\n    &#123;\n        if(heap[i]&lt;heap[j]) swap(heap[i],heap[j]);\n        else return; // heap[i]&gt;=heap[j]说明插入的值并不比父节点大，有序性得以保证\n        i=j;\n        j=i/2;\n    &#125;\n    return;\n&#125;\nint main()\n&#123;\n    int n,Heap[maxn],stamina,size;\n    cin&gt;&gt;n;\n    size=n;\n    stamina=0;\n    heapinit(Heap,n);\n    if(n==1)\n    &#123;\n        cout&lt;&lt;Heap[1];\n        return 1;\n    &#125;\n    // stamina 的消耗可以堆顶的访问删除来实现\n    // 通过将堆顶与堆底互换并回收堆底，保持访问堆的结构不变，通过维护保持堆的有序\n    // 回收（size--通过大小的减小停止对堆底的维护，即回收）未删除数据但不影响\n    while(size&gt;1)\n    &#123;\n        int a = Heap[1];\n        deletetop(Heap,size);\n        int b=Heap[1];\n        deletetop(Heap,size);\n       \n        insertheap(Heap,size,a+b);// value isn't equal to stamina cost totally\n        stamina+=(a+b);\n\n    &#125;\n    cout&lt;&lt;stamina;\n&#125;\n</code></pre>\n<p>结语：涉及二叉堆的生成与维护，要注意对堆顶 pop 时 (也就是上文中的 deletetop 函数，topnode 的值并没有被删除，而是放在了堆底回收区，堆的大小并不是真正意义上所占全部空间的大小，而是有效空间的大小)</p>\n<h4 id=\"方法二优先队列\"><a class=\"anchor\" href=\"#方法二优先队列\">#</a> 方法二：优先队列</h4>\n<p>代码及思路如下</p>\n<pre><code class=\"language-c++\">#include &lt;queue&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; que;\n    // greater 增序，使最小的位于top\n    int n, i, stamina = 0;\n    cin &gt;&gt; n;\n    i = n;\n    while (i--)\n    &#123;\n        int x;\n        cin &gt;&gt; x;\n        que.push(x);\n    &#125;// 输入que，自动排序\n    if (n == 1)\n    &#123;\n        int x = que.top();\n        cout &lt;&lt; x;\n        que.pop();\n    &#125;\n    while (que.size() &gt; 1)\n    &#123;\n        int a = que.top();\n        que.pop();\n        int b = que.top();\n        que.pop();\n        stamina += (a + b);\n        que.push(a + b);\n    &#125;\n    //que.top()=sum 所有之和，不用计算到体力消耗\n\n\n    cout &lt;&lt; stamina;\n&#125;\n\n</code></pre>\n<p>结语：相比于使用小顶堆，使用优先队列的代码无疑简介易懂。</p>\n<p>然而事实上优先队列本质上使用的也是堆的思想。二者在时间效率上，是前者更优。<s>(specific 优于 general)</s> 😃</p>\n<p>参考资料：</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3QuY3Nkbi5jbi82dXBFSw==\">Possible_Answer</span>,</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xODc2MTg0NTA=\"> 二叉堆 -- 知乎</span>，</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3QuY3Nkbi5jbi8yQ1o0YQ==\">优先队列</span>，<span class=\"exturl\" data-url=\"aHR0cDovL3QuY3Nkbi5jbi9DNlA0aA==\">优先队列 (实例)</span>,</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTU0NjcwMDA=\">数据结构 —— 哈夫曼树 (Huffman Tree)</span>,(知识扩展)</p>\n</blockquote>\n<hr />\n<blockquote>\n<p>写在最后，这里出于课程要求，并没有考虑快排的方法，事实上快排无疑也是一种解决方案</p>\n</blockquote>\n",
            "tags": [
                "Notes",
                "C++"
            ]
        },
        {
            "id": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E5%B0%8F%E6%9C%A8%E6%A3%8D%E7%BB%84%E6%AD%A3%E6%96%B9%E5%BD%A2/",
            "url": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/%E5%B0%8F%E6%9C%A8%E6%A3%8D%E7%BB%84%E6%AD%A3%E6%96%B9%E5%BD%A2/",
            "title": "小木棍组正方形",
            "date_published": "2023-03-19T11:29:17.362Z",
            "content_html": "<p>小木棍组正方形：</p>\n<p>解题思路：</p>\n<p>使用 DFS 算法，并减去一些枝干</p>\n<p>代码如下</p>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nint sticks[38]&#123;0&#125;;//存放木棍长度\n\nint side, groupnum, n;\nbool DFS(int sum, int number, int pos,int * flag)\n&#123;\n    if (number == 3)\n        return true;\n\n    for(int i=pos;i&lt;n;i++)\n    &#123;\n        if(sum+sticks[pos]&gt;side)&#123;\n            continue;\n        &#125;\n        if(flag[i]==1)\n        &#123;\n            continue;\n        &#125;\n        if(sum+sticks[i]==side)// 深度搜索\n        &#123;\n            if(DFS(0,number+1,0,flag)) return true;\n        &#125;\n        else\n        &#123;\n            if(DFS(sum+sticks[i],number,0,flag)) return true;\n        &#125;//深度搜索不能返回true，则返回上一节点，寻找其他子节点，通过for实现\n        flag[i]=0;\n    &#125;\n    return false;\n&#125;\n\nint main()\n&#123;\n\n    cin &gt;&gt; groupnum;\n    while (groupnum--)\n    &#123;\n        int flag[38]&#123;0&#125;;\n        cin &gt;&gt; n;\n        int s = 0;\n        for (int i = 0; i &lt; n; i++)\n        &#123;\n            cin &gt;&gt; sticks[i];\n            s += sticks[i];\n        &#125;\n        if (s % 4 != 0)\n        &#123;\n            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;\n            continue;\n        &#125;\n        side = s / 4;\n\n        sort(sticks, sticks + n, greater&lt;int&gt;());\n        if (sticks[0] &gt; side)\n        &#123;\n            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;\n            continue;\n        &#125;\n        if (DFS(0, 0, 0,flag))\n            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;\n        else \n            cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;\n    &#125;\n&#125;\n</code></pre>\n<p>结语：</p>\n<p>DFS 模板</p>\n<pre><code class=\"language-c++\">int check(参数)\n&#123;\n    if(满足条件)\n        return 1;\n    return 0;\n&#125;\n \nvoid dfs(int step)\n&#123;\n        判断边界\n        &#123;\n            相应操作\n        &#125;\n        尝试每一种可能\n        &#123;\n               满足check条件\n               标记\n               继续下一步dfs(step+1)\n               恢复初始状态（回溯的时候要用到）\n        &#125;\n&#125;   \n</code></pre>\n<p>参考资料</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3QuY3Nkbi5jbi9FZjhNUQ==\">http://t.csdn.cn/Ef8MQ</span> DFS 算法解释及例题</p>\n",
            "tags": [
                "Notes",
                "C++"
            ]
        },
        {
            "id": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/",
            "url": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/",
            "title": "棋盘问题",
            "date_published": "2023-03-19T11:29:17.362Z",
            "content_html": "<h4 id=\"问题描述\"><a class=\"anchor\" href=\"#问题描述\">#</a> 问题描述</h4>\n<blockquote>\n<p>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放 k 个棋子的所有可行的摆放方案 C。</p>\n</blockquote>\n<h5 id=\"输入\"><a class=\"anchor\" href=\"#输入\">#</a> 输入</h5>\n<blockquote>\n<p>输入含有多组测试数据。<br />\n每组数据的第一行是两个正整数 *，n k*，用一个空格隔开，表示了将在一个 n*n 的矩阵内描述棋盘，以及摆放棋子的数目。</p>\n<p>n &lt;= 8 , k &lt;= n</p>\n<p>当为 **-1 -1** 时表示输入结束。<br />\n随后的 n 行描述了棋盘的形状：每行有 n 个字符，其中  <code>#</code>  表示棋盘区域， <code>.</code>  表示空白区域（数据保证不出现多余的空白行或者空白列）。</p>\n</blockquote>\n<h5 id=\"输出\"><a class=\"anchor\" href=\"#输出\">#</a> 输出</h5>\n<blockquote>\n<p>对于每一组数据，给出一行输出，输出摆放的方案数目 C （<em>数据保证 C&lt;2^31</em>）。</p>\n</blockquote>\n<h5 id=\"样例输入\"><a class=\"anchor\" href=\"#样例输入\">#</a> 样例输入</h5>\n<figure class=\"highlight plain\"><figcaption data-lang=\"plain\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>2 1</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>#.</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>.#</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>4 4</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>...#</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>..#.</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>.#..</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>#...</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>-1 -1</pre></td></tr></table></figure><h5 id=\"样例输出\"><a class=\"anchor\" href=\"#样例输出\">#</a> 样例输出</h5>\n<figure class=\"highlight plain\"><figcaption data-lang=\"plain\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>1</pre></td></tr></table></figure><h4 id=\"解题思路\"><a class=\"anchor\" href=\"#解题思路\">#</a> 解题思路</h4>\n<p><strong>代码如下</strong>:</p>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string.h&gt;\nusing namespace std;\n\nint n, k, ans, a[64], j; // n 方阵长度，k棋子个数,ans is answer\n\nint visit[8][8]&#123;0&#125;; // shows which cloumn and row is not placeable\n\nstruct Node\n&#123;\n    int *flag;\n    int p = 0;// in fact, the param is redundant\n&#125;;\n// 如果为0则空，1则有棋盘’#‘\nNode qiju[100];\n// 进行遍历// 考虑使用下标 从1开始\n\nvoid dfs(int idx, int num)\n&#123;\n    if (num == k)\n        ans++; // plan + 1\n    else\n    &#123;\n        for (int i = idx; i &lt; j; i++) // each qipan has possiblity\n        &#123;\n            if (*qiju[a[i]].flag == 1)\n                continue;\n            *qiju[a[i]].flag = 1; //\n            dfs(0, num + 1);\n        &#125;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    char ch;\n    while (cin &gt;&gt; n &gt;&gt; k)\n    &#123;\n        if (n == -1 &amp;&amp; k == -1)\n            break;\n        j = 0;\n        ans = 0;\n        memset(qiju, 0, sizeof(qiju));\n        memset(visit, 0, sizeof(visit));\n\n        for (int i = 0; i &lt; n * n; i++)\n        &#123;\n\n            cin &gt;&gt; ch;\n            switch (ch)\n            &#123;\n            case '.':\n                break;\n            case '#':\n\n                qiju[i].p = 1;// when I have created array a, \n                    \t\t//I can visit qiju by a, \n                    \t\t//in this situation param p is redundant.\n                qiju[i].flag = &amp;visit[i / n][i % n]; // point to position\n                a[j] = i;                            // restore qipan position with arry a\n                j++;\n                break;\n            &#125;\n        &#125;\n        dfs(0, 0);\n        cout &lt;&lt; ans &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"结语\"><a class=\"anchor\" href=\"#结语\">#</a> 结语</h4>\n<p>通过 visit 标记状态，通过 node 取地址，使每个棋盘的状态得以被标示，同时通过 node 数组，a 数组实现快速访问，规避无效数据。</p>\n<h4 id=\"参考资料\"><a class=\"anchor\" href=\"#参考资料\">#</a> 参考资料</h4>\n<blockquote>\n<p>DFS 深度优先搜索算法</p>\n</blockquote>\n",
            "tags": [
                "Notes",
                "C++",
                "DFS"
            ]
        },
        {
            "id": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/",
            "url": "https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/",
            "title": "迷宫问题",
            "date_published": "2023-03-19T11:29:17.362Z",
            "content_html": "<p>问题描述</p>\n<p>解决思路</p>\n<p>代码如下</p>\n<p>结语：</p>\n<p>迷宫问题很重要的就是路径，方向，路径使用栈，方向通过 2X4 的数组描述，关键在于，在平面上点的坐标可以用 (x,y) 描述，给它加上</p>\n<p>(1,0)((-1,0),(0,1),(0,-1)) 就实现了向右 (左，上，下) 移动。</p>\n<p>参考资料</p>\n",
            "tags": [
                "Notes",
                "C++",
                "DFS"
            ]
        }
    ]
}