<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://evefortosaber.github.io</id>
    <title>流云阁 • Posts by &#34;dfs&#34; category</title>
    <link href="https://evefortosaber.github.io" />
    <updated>2023-03-19T11:29:17.362Z</updated>
    <category term="Notes" />
    <category term="随笔" />
    <category term="C++" />
    <category term="CTF" />
    <category term="DFS" />
    <entry>
        <id>https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</id>
        <title>棋盘问题</title>
        <link rel="alternate" href="https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;h4 id=&#34;问题描述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#问题描述&#34;&gt;#&lt;/a&gt; 问题描述&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放 k 个棋子的所有可行的摆放方案 C。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;输入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输入&#34;&gt;#&lt;/a&gt; 输入&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;输入含有多组测试数据。&lt;br /&gt;
每组数据的第一行是两个正整数 *，n k*，用一个空格隔开，表示了将在一个 n*n 的矩阵内描述棋盘，以及摆放棋子的数目。&lt;/p&gt;
&lt;p&gt;n &amp;lt;= 8 , k &amp;lt;= n&lt;/p&gt;
&lt;p&gt;当为 **-1 -1** 时表示输入结束。&lt;br /&gt;
随后的 n 行描述了棋盘的形状：每行有 n 个字符，其中  &lt;code&gt;#&lt;/code&gt;  表示棋盘区域， &lt;code&gt;.&lt;/code&gt;  表示空白区域（数据保证不出现多余的空白行或者空白列）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输出&#34;&gt;#&lt;/a&gt; 输出&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;对于每一组数据，给出一行输出，输出摆放的方案数目 C （&lt;em&gt;数据保证 C&amp;lt;2^31&lt;/em&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;样例输入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#样例输入&#34;&gt;#&lt;/a&gt; 样例输入&lt;/h5&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;figcaption data-lang=&#34;plain&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;2 1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.#&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;4 4&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;...#&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;..#.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;.#..&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;#...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;-1 -1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h5 id=&#34;样例输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#样例输出&#34;&gt;#&lt;/a&gt; 样例输出&lt;/h5&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;figcaption data-lang=&#34;plain&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 id=&#34;解题思路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#解题思路&#34;&gt;#&lt;/a&gt; 解题思路&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;代码如下&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;
using namespace std;

int n, k, ans, a[64], j; // n 方阵长度，k棋子个数,ans is answer

int visit[8][8]&amp;#123;0&amp;#125;; // shows which cloumn and row is not placeable

struct Node
&amp;#123;
    int *flag;
    int p = 0;// in fact, the param is redundant
&amp;#125;;
// 如果为0则空，1则有棋盘’#‘
Node qiju[100];
// 进行遍历// 考虑使用下标 从1开始

void dfs(int idx, int num)
&amp;#123;
    if (num == k)
        ans++; // plan + 1
    else
    &amp;#123;
        for (int i = idx; i &amp;lt; j; i++) // each qipan has possiblity
        &amp;#123;
            if (*qiju[a[i]].flag == 1)
                continue;
            *qiju[a[i]].flag = 1; //
            dfs(0, num + 1);
        &amp;#125;
    &amp;#125;
&amp;#125;

int main()
&amp;#123;
    char ch;
    while (cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k)
    &amp;#123;
        if (n == -1 &amp;amp;&amp;amp; k == -1)
            break;
        j = 0;
        ans = 0;
        memset(qiju, 0, sizeof(qiju));
        memset(visit, 0, sizeof(visit));

        for (int i = 0; i &amp;lt; n * n; i++)
        &amp;#123;

            cin &amp;gt;&amp;gt; ch;
            switch (ch)
            &amp;#123;
            case &#39;.&#39;:
                break;
            case &#39;#&#39;:

                qiju[i].p = 1;// when I have created array a, 
                    		//I can visit qiju by a, 
                    		//in this situation param p is redundant.
                qiju[i].flag = &amp;amp;visit[i / n][i % n]; // point to position
                a[j] = i;                            // restore qipan position with arry a
                j++;
                break;
            &amp;#125;
        &amp;#125;
        dfs(0, 0);
        cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    &amp;#125;
    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;结语&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结语&#34;&gt;#&lt;/a&gt; 结语&lt;/h4&gt;
&lt;p&gt;通过 visit 标记状态，通过 node 取地址，使每个棋盘的状态得以被标示，同时通过 node 数组，a 数组实现快速访问，规避无效数据。&lt;/p&gt;
&lt;h4 id=&#34;参考资料&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#参考资料&#34;&gt;#&lt;/a&gt; 参考资料&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;DFS 深度优先搜索算法&lt;/p&gt;
&lt;/blockquote&gt;
</content>
        <category term="Notes" />
        <category term="C++" />
        <category term="DFS" />
        <updated>2023-03-19T11:29:17.362Z</updated>
    </entry>
    <entry>
        <id>https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/</id>
        <title>迷宫问题</title>
        <link rel="alternate" href="https://evefortosaber.github.io/2023/03/19/ComputerScience/ProgramDesignNotes/DFS/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;解决思路&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;p&gt;结语：&lt;/p&gt;
&lt;p&gt;迷宫问题很重要的就是路径，方向，路径使用栈，方向通过 2X4 的数组描述，关键在于，在平面上点的坐标可以用 (x,y) 描述，给它加上&lt;/p&gt;
&lt;p&gt;(1,0)((-1,0),(0,1),(0,-1)) 就实现了向右 (左，上，下) 移动。&lt;/p&gt;
&lt;p&gt;参考资料&lt;/p&gt;
</content>
        <category term="Notes" />
        <category term="C++" />
        <category term="DFS" />
        <updated>2023-03-19T11:29:17.362Z</updated>
    </entry>
</feed>
